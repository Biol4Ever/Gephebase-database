<?php

/*

 Copyright 2019 CNRS.

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License,
 or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/


namespace AppBundle\Repository;

use Doctrine\ORM\EntityRepository;
use AppBundle\Entity\EntryStatus;
use AppBundle\Entity\EntryStatusGroup;
use AppBundle\Entity\Entry;
use AppBundle\EventListener\NewEntryListener;

/**
 * EntryRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EntryRepository extends EntityRepository
{
    const EXACT_SEARCH_CHAR = '^';

    private $branch = null;

	public function selectAllExportCsv($entries) {
        $em = $this->getEntityManager();

        $entries = $em->createQuery('SELECT e.id AS id,
                                          e.gepheId AS gepheId,
                                          e.geneGephebase,
                                          g.uniProtKbId,
                                          g.name AS geneName,
                                          e.genbankId,
                                          e.ancestralState,
                                          e.taxonomicStatus,
                                          e.comments,
                                          u.username,
                                          m.id
                                   FROM AppBundle:Entry e 
                                   LEFT JOIN AppBundle:Gene g                   WITH e.gene = g.id
                                   LEFT JOIN AppBundle:User u                   WITH e.mainCurator = u.id
                                   LEFT JOIN AppBundle:Mutation m               WITH m.entry = e
                                   WHERE e.id IN ('.implode(',', array_map('intval',$entries)).') GROUP BY m.id ORDER BY e.id ASC')->getResult();

        $complexTraits = $this->findAllComplexTraits();
        $complexTaxonAs = $this->findAllComplexTaxons('A');
        $complexTaxonBs = $this->findAllComplexTaxons('B');
        $mutations = $this->findAllMutations();
        $feedbacks = $this->findAllFeedbacks();

        foreach ($entries as $key => $entry) {
            // add traits to array
            $this->addCollectionItemToEntryArray('complexTraits', $complexTraits, $entry, $key, $entries);
            // add complex taxon As to array
            $this->addCollectionItemToEntryArray('complexTaxonAs', $complexTaxonAs, $entry, $key, $entries);
            // add complex taxon Bs to array
            $this->addCollectionItemToEntryArray('complexTaxonBs', $complexTaxonBs, $entry, $key, $entries);
            // add mutations to array
            $this->addCollectionItemToEntryArray('mutations', $mutations, $entry, $key, $entries);
            // add feedbacks to array
            $this->addCollectionItemToEntryArray('feedbacks', $feedbacks, $entry, $key, $entries);
        }

        return $entries;
	}

    public function selectAllExportCsvComplete($entries)
    {
        $em = $this->getEntityManager();

        $entries = $em->createQuery('SELECT e.id AS id,
                                          e.gepheId AS gepheId,
                                          e.geneGephebase,
                                          g.id AS geneId,
                                          g.name AS geneName,
                                          g.uniProtKbId,
                                          e.genbankId,
                                          e.ancestralState,
                                          e.taxonomicStatus,
                                          e.comments,
                                          g.organism,
                                          g.string AS string,
                                          g.sequenceSimilarities AS similarities,
                                          u.username
                                   FROM AppBundle:Entry e 
                                   LEFT JOIN AppBundle:Gene g                   WITH e.gene = g.id
                                   LEFT JOIN AppBundle:User u                   WITH e.mainCurator = u.id
                                   WHERE e.id IN ('.implode(',', array_map('intval',$entries)).') GROUP BY e.id ORDER BY e.id ASC')->getResult();
       
        $complexTraits = $this->findAllComplexTraits();
        $complexTaxonAs = $this->findAllComplexTaxons('A');
        $complexTaxonBs = $this->findAllComplexTaxons('B');
        $goMoleculars = $this->findAllGo('goMolecular');
        $goBiologicals = $this->findAllGo('goBiological');
        $goCellulars = $this->findAllGo('goCellular');
        $geneSynonyms = $this->findAllSynonyms();
        $mutations = $this->findAllMutations();
        $feedbacks = $this->findAllFeedbacks();
        foreach ($entries as $key => $entry) {
            // add traits to array
            $this->addCollectionItemToEntryArray('complexTraits', $complexTraits, $entry, $key, $entries);
            // add complex taxon As to array
            $this->addCollectionItemToEntryArray('complexTaxonAs', $complexTaxonAs, $entry, $key, $entries);
            // add complex taxon Bs to array
            $this->addCollectionItemToEntryArray('complexTaxonBs', $complexTaxonBs, $entry, $key, $entries);
            // add mutations to array
            $this->addCollectionItemToEntryArray('mutations', $mutations, $entry, $key, $entries);
            // add feedbacks to array
            $this->addCollectionItemToEntryArray('feedbacks', $feedbacks, $entry, $key, $entries);
            // add go Moleculars to array
            $this->addCollectionItemToEntryArray('goMoleculars', $goMoleculars, $entry, $key, $entries, 'geneId');
            // add go Biological to array
            $this->addCollectionItemToEntryArray('goBiologicals', $goBiologicals, $entry, $key, $entries, 'geneId');
            // add go Cellular to array
            $this->addCollectionItemToEntryArray('goCellulars', $goCellulars, $entry, $key, $entries, 'geneId');
            // add gene synonyms to array
            $this->addCollectionItemToEntryArray('geneSynonyms', $geneSynonyms, $entry, $key, $entries, 'geneId');
        }

        return $entries;

    }

    public function search($query) {

        $em = $this->getEntityManager();
        $entries = $em->createQuery("SELECT e.taxonADescription AS taxonAName,
                                        e.taxonBDescription AS taxonBName,
                                        e.gepheId AS gepheID,
                                        g.name AS geneName,
                                        e.geneGephebase AS geneGephebase,
                                        g.uniProtKbId AS uniProtKbId,
                                        p.description AS trait,
                                        e.id AS id,
                                        s.name AS synonyms
                                 FROM AppBundle:Entry e 
                                        LEFT JOIN AppBundle:Taxon ta                 WITH e.taxonA = ta.id   
                                        LEFT JOIN AppBundle:Taxon tb                 WITH e.taxonB = tb.id
                                        LEFT JOIN AppBundle:PhenotypeTrait p         WITH e.phenotypeTrait = p.id
                                        LEFT JOIN AppBundle:Gene g                   WITH e.gene = g.id
                                        LEFT JOIN g.synonyms s 
                                 WHERE (e.taxonADescription             LIKE :query 
                                        OR e.taxonBDescription         LIKE :query
                                        OR e.gepheId       LIKE :query
                                        OR g.name          LIKE :query
                                        OR e.geneGephebase LIKE :query
                                        OR s.name          LIKE :query
                                        OR g.uniProtKbId   LIKE :query
                                        OR p.description   LIKE :query)AND e.status = :status")->setParameters(array('query' => '%'.$query.'%', 'status' => EntryStatus::ACCEPTED_CURATOR ))->getScalarResult();
        return $entries;
    }

    public function searchGeneGephebase($term) {
        $em = $this->getEntityManager();
        $sql = $em->createQuery("SELECT DISTINCT(e.geneGephebase) AS geneGephebase
                                 FROM AppBundle:Entry e 
                                 WHERE e.geneGephebase LIKE :term")->setParameter('term', '%'.$term.'%')->getResult();
        return $sql;
    }

    public function searchUniprot($term) {
        $em = $this->getEntityManager();
        $sql = $em->createQuery("SELECT DISTINCT(g.uniProtKbId) AS uniProtKbId
                                 FROM AppBundle:Entry e LEFT JOIN AppBundle:Gene g WITH e.gene = g.id
                                 WHERE g.uniProtKbId LIKE :term")->setParameter('term', '%'.$term.'%')->getResult();
        return $sql;
    }

    public function searchGenbank($term) {
        $em = $this->getEntityManager();
        $sql = $em->createQuery("SELECT DISTINCT(e.genbankId) AS genbank FROM AppBundle:Entry e WHERE e.genbankId LIKE :term")->setParameter('term', '%'.$term.'%')->getResult();
        return $sql;
    }

    public function searchMolecularDetails($term) {
        $em = $this->getEntityManager();
        $sql = $em->createQuery("SELECT DISTINCT(e.molecularDetails) AS molecularDetails FROM AppBundle:Entry e WHERE e.molecularDetails LIKE :term")->setParameter('term', '%'.$term.'%')->getResult();
        return $sql;
    }

    public function simpleSearch($value, $sc)
    {
        $finalResults = $this->searchAll($value, $sc, 'and');

        //usort($finalResults, array($this, "sortByGepheId"));

        return $finalResults;
    }

    public function searchAll($value, $sc = null, $operator = 'and', $mutationSearch = false)
    {
      $sqlOperator = 'LIKE';
      if ($operator === 'not') {
        $sqlOperator = 'NOT LIKE';
      }


      // break down the search query into search values according to syntax
      $values = array();
      $exactSearch = false;
      if ($this->isExactSearch($value)) {
        $values[] = str_replace(self::EXACT_SEARCH_CHAR, '', $value);
        $exactSearch = true;
      } else {
        // Get all strings between ""
        $count_quotes = substr_count($value, '"');
        $values_quotes = array(); 
        for($i = 1; $i <= ($count_quotes / 2); $i++) {
          if(!isset($first)){
            $first = strpos($value, '"');
          } else {
            $first = strpos($value, '"', $first + 1);
          }
          $second = strpos($value, '"', $first + 1);
          $range = $second - $first;
          $values_quotes[] = trim(substr($value, $first + 1, $range - 1));
          $first = $second;
        }

        // Delete all values found under quotes from the string
        foreach($values_quotes as $value_quote) {
          $value = str_replace($value_quote, "", $value);
        }

        // Delete all quotes from the string
        $value = trim(str_replace('"', "", $value));

        // Split all spaces to an array
        $value = str_replace(array(',', '.', ';'), ' ', $value);
        $values = preg_split('/\s+/', $value);
        $values = array_filter($values, function($value) { return $value !== '';});

        // Merge the values with the values under quotes into one array
        $values = array_merge($values, $values_quotes);
      }

        $searchableTables = Entry::getSearchableTables();
        $selector = 'e.id';
        if ($mutationSearch) {
          $selector = 'm.id';
        }

        $queryBuilders = array();
        foreach ($searchableTables as $table) {
          $searchGroup = $table['searchGroup'];
          if (array_key_exists($searchGroup, $queryBuilders)) {
            $qb = $queryBuilders[$searchGroup]['qb'];
            $orx = $queryBuilders[$searchGroup]['orx'];
          } else {
            $qb = $this->getEntityManager()->createQueryBuilder();
            $qb->select($selector)
              ->from('AppBundle:Entry', 'e')
              ->where('e.status = :status')
              ->orWhere('e.status = :statusAcceptedValidator')
              ->orWhere('e.status = :statusRefusedValidator')                
              ->orderBy('e.id', 'DESC')
              ->groupBy($selector)
              ->setParameter('status', EntryStatus::ACCEPTED_CURATOR)
              ->setParameter('statusAcceptedValidator', EntryStatus::ACCEPTED_VALIDATOR)
              ->setParameter('statusRefusedValidator', EntryStatus::REFUSED_VALIDATOR);

              if($sc->isGranted('ROLE_CURATOR')) {
                $qb
                  ->orWhere('e.status = :statusImported')
                  ->orWhere('e.status = :statusTemporary')
                  ->setParameter('statusImported', EntryStatus::IMPORTED)
                  ->setParameter('statusTemporary', EntryStatus::TEMPORARY);   
              }

            $orX = $qb->expr()->orX();
            
            if ($searchGroup === 'general') {
              $orX->add('e.gepheId '. $sqlOperator .' :value');
              $orX->add('e.geneGephebase '. $sqlOperator .' :value');
              $orX->add('e.genbankId '. $sqlOperator .' :value');
              $orX->add('e.comments '. $sqlOperator .' :value');
            }
            $queryBuilders[$searchGroup]['qb'] = $qb;
            $queryBuilders[$searchGroup]['orx'] = $orX;
            
          }
          if ($table['type'] === 'toOne') {
            $qb->leftJoin('AppBundle:'.$table['table'], $table['shorthand'], 'WITH', $table['joinColumn'] . ' = ' . $table['referenceColumn']);
          } elseif ($table['type'] === 'toMany') {
            $qb->leftJoin($table['joinColumn'], $table['shorthand']);
          }

          foreach($table['searchFields'] as $searchField) {

            $orX->add($table['shorthand'].'.'.$searchField . ' '. $sqlOperator .' :value');
          }

        }

        $results = array();

        for ($i=0; $i < sizeof($values); $i++) { 
          $param = ':value'.$i;
          $value = $values[$i];

          foreach ($queryBuilders as $type => $queryBuilder) {
            // add mutation join if isn't there already
            $qb = clone $queryBuilder['qb'];
            $qb = $this->addMutationJoin($qb);
            $orX = $queryBuilder['orx'];

            $placeholderOrX = $qb->expr()->orX();
            if ($operator === 'not') {
                $placeholderOrX = $qb->expr()->andX();
            }
            foreach ($orX->getParts() as $part) {
              if ($operator === 'not') {
                $innerOrX = $qb->expr()->orX();
                $innerOrX->add(str_replace(':value', $param, $part));
                $innerOrX->add(str_replace('NOT LIKE :value', 'IS NULL', $part));
                $placeholderOrX->add($innerOrX);
              } else {
                $placeholderOrX->add(str_replace(':value', $param, $part));
              }
            }

            if(strpos($value, '*') !== false) {
              $value = str_replace('*', '%', $value);
            }
            if ($exactSearch) {
              $qb->setParameter($param, $value);
            } else {
              $qb->setParameter($param, '%'.$value.'%');
            }
            $qb->andWhere($placeholderOrX);

            $result = $qb->getQuery()->getResult();

            if (array_key_exists($param, $results)) {
              if ($operator === 'not') {
                $results[$param] = array_uintersect($results[$param], $result, function ($e1, $e2) {

                  if (is_object($e1)) {
                    $e1 = spl_object_hash($e1);
                  } elseif(is_array($e1)) {
                    $e1 = $e2['id'];
                  }

                  if (is_object($e2)) {
                    $e2 = spl_object_hash($e2);
                  } elseif(is_array($e2)) {
                    $e2 = $e2['id'];
                  }

                  return strcmp($e1, $e2);
                });
              } else {
                $results[$param] = array_merge($results[$param], $result);
              }
            } else {
              $results[$param] = $result;
            }
          }
        }

        $finalResults = array();
        $first = true;
        foreach ($results as $result) {
          if ($first) {
            $finalResults = $result;
            $first = false;
            continue;
          }

          $finalResults = array_uintersect($finalResults, $result, function($id1, $id2) {
            return strcmp($id1['id'], $id2['id']);
          });
          /*$finalResults = array_uintersect($finalResults, $result, function ($e1, $e2) {
            return strcmp(spl_object_hash($e1), spl_object_hash($e2));
          });*/
        }

        return $finalResults;
    }


    public function listImportedEntries()
    {   
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, e.gepheId, e.geneGephebase')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.id = :imported')
            ->setParameter(':imported', EntryStatus::IMPORTED);

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            // we need to fetch traits and taxon B as well
            $traits = $this->findAllTraits();
            $taxonBs = $this->findAllTaxons('B');
            $importedTaxonBs = $this->findAllImportedTaxonBs();

            foreach ($entries as $key => $entry) {
                // add traits to array
                $this->addCollectionItemToEntryArray('traits', $traits, $entry, $key, $entries);
                // add taxon B to array
                $this->addCollectionItemToEntryArray('taxonB', $taxonBs, $entry, $key, $entries);
                // add all unfetched taxon Bs
                $this->addCollectionItemToEntryArray('unfetchedTaxonB', $importedTaxonBs, $entry, $key, $entries);
            }

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function findAllImportedEntries()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.id = :imported')
            ->setParameter(':imported', EntryStatus::IMPORTED);

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function listRefusedEntries()
    {   
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.id = :refused')
            ->setParameter(':refused', EntryStatus::REFUSED_VALIDATOR);

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function listDraftEntries()
    {   
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, e.gepheId, e.geneGephebase')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.statusGroup = :draft')
            ->orderBy('e.gepheId', 'ASC')
            ->setParameter(':draft', EntryStatusGroup::DRAFT);

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            // we need to fetch traits and taxon B as well
            $traits = $this->findAllTraits();
            $taxonBs = $this->findAllTaxons('B');
            $importedTaxonBs = $this->findAllImportedTaxonBs();

            foreach ($entries as $key => $entry) {
                // add traits to array
                $this->addCollectionItemToEntryArray('traits', $traits, $entry, $key, $entries);
                // add taxon B to array
                $this->addCollectionItemToEntryArray('taxonB', $taxonBs, $entry, $key, $entries);
                // add all unfetched taxon Bs
                $this->addCollectionItemToEntryArray('unfetchedTaxonB', $importedTaxonBs, $entry, $key, $entries);
            }

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function listDeletedEntries()
    {   
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, e.gepheId, e.geneGephebase')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.id = :trash')
            ->setParameter(':trash', EntryStatus::DELETED);

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            // we need to fetch traits and taxon B as well
            $traits = $this->findAllTraits();
            $taxonBs = $this->findAllTaxons('B');
            $importedTaxonBs = $this->findAllImportedTaxonBs();

            foreach ($entries as $key => $entry) {
                // add traits to array
                $this->addCollectionItemToEntryArray('traits', $traits, $entry, $key, $entries);
                // add taxon B to array
                $this->addCollectionItemToEntryArray('taxonB', $taxonBs, $entry, $key, $entries);
                // add all unfetched taxon Bs
                $this->addCollectionItemToEntryArray('unfetchedTaxonB', $importedTaxonBs, $entry, $key, $entries);
            }

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function listToReviewEntries()
    {   
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, e.gepheId, e.geneGephebase')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.id = :reviewed')
            ->andWhere('e.feedbacks is not empty')
            ->setParameter(':reviewed', EntryStatus::REFUSED_VALIDATOR);

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            // we need to fetch traits and taxon B as well
            $traits = $this->findAllTraits();
            $taxonBs = $this->findAllTaxons('B');
            $importedTaxonBs = $this->findAllImportedTaxonBs();

            foreach ($entries as $key => $entry) {
                // add traits to array
                $this->addCollectionItemToEntryArray('traits', $traits, $entry, $key, $entries);
                // add taxon B to array
                $this->addCollectionItemToEntryArray('taxonB', $taxonBs, $entry, $key, $entries);
                // add all unfetched taxon Bs
                $this->addCollectionItemToEntryArray('unfetchedTaxonB', $importedTaxonBs, $entry, $key, $entries);
            }

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function listOtherEntries()
    {   
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, e.gepheId, e.geneGephebase')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.id = :other')
            ->setParameter(':other', EntryStatus::TEMPORARY);

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            // we need to fetch traits and taxon B as well
            $traits = $this->findAllTraits();
            $taxonBs = $this->findAllTaxons('B');
            $importedTaxonBs = $this->findAllImportedTaxonBs();

            foreach ($entries as $key => $entry) {
                // add traits to array
                $this->addCollectionItemToEntryArray('traits', $traits, $entry, $key, $entries);
                // add taxon B to array
                $this->addCollectionItemToEntryArray('taxonB', $taxonBs, $entry, $key, $entries);
                // add all unfetched taxon Bs
                $this->addCollectionItemToEntryArray('unfetchedTaxonB', $importedTaxonBs, $entry, $key, $entries);
            }

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function listValidatorEntries($validator)
    {   
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->innerJoin('AppBundle:User', 'u', 'WITH', 'u MEMBER OF e.validators')
            ->where('u.id = :validator')
            ->andWhere('es.id = :validate')
            ->setParameters(array(':validator'=> $validator->getId(), ':validate' => EntryStatus::ACCEPTED_CURATOR));

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function listUnvalidatedEntries($userId) {
      $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e')
            ->addSelect('(CASE WHEN e.mainCurator <> '.$userId.' THEN 0 ELSE 1 END) AS HIDDEN ORD')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:Mutation','m','WITH','m.entry = e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.id = :accepted')
            ->groupBy('m.id')
            ->add('orderBy', 'e.gepheId DESC, ORD ASC, e.dateEmail ASC')
            ->setParameter(':accepted', EntryStatus::ACCEPTED_CURATOR);

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function findNextImportedEntry($id)
    {
      $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('es.id = :imported')
            ->setParameter(':imported', EntryStatus::IMPORTED)
            ->andWhere('e.id > :current')
            ->setParameter(':current', $id)
            ->setMaxResults(1);

        $query = $qb->getQuery();

        try 
        {
            $next = $query->getArrayResult();
            if($next) {
              return $next[0]['id'];
            } else {
              return null;
            }
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    public function searchWithField($field, $term, $sc)
    {
        $em = $this->getEntityManager();
      // Create different query for different $field.
      $maxResults = 20;
      $groupBy = '';
      switch ($field) {
        case 0:
        $query = "SELECT e.gepheId AS gepheID, e.genbankId as genbank, g.name AS gene, ta.latinName AS latinAName, ta.commonName AS commonAName, ta.latinName AS latinBName, ta.commonName AS commonBName, g.uniProtKbId AS uniprotkbid, p.description AS description, e.geneGephebase AS geneGephebase FROM AppBundle:Entry e LEFT JOIN AppBundle:Gene g WITH e.gene = g.id LEFT JOIN AppBundle:ComplexTaxon cta WITH cta.entryAsTaxonA = e LEFT JOIN AppBundle:Taxon ta WITH cta.taxon = ta.id LEFT JOIN AppBundle:ComplexTaxon ctb WITH ctb.entryAsTaxonB = e LEFT JOIN AppBundle:Taxon tb WITH ctb.taxon = tb.id LEFT JOIN AppBundle:ComplexTrait cpt WITH cpt.entry = e LEFT JOIN AppBundle:PhenotypeTrait p WITH cpt.phenotypeTrait = p.id WHERE (e.gepheId LIKE :term OR e.geneGephebase LIKE :term OR e.genbankId LIKE :term OR g.name LIKE :term OR ta.name LIKE :term OR tb.name LIKE :term OR g.uniProtKbId LIKE :term OR p.description LIKE :term)";
          break; 
        case 1:
          $query = "SELECT es.name AS status FROM AppBundle:Entry e LEFT JOIN AppBundle:EntryStatus es WITH e.status = es.id WHERE es.name LIKE :term";
          break;
        case 2:
          $query = "SELECT u.name AS username, u.surname AS surname FROM AppBundle:User u WHERE u.roles LIKE :curator AND (u.name LIKE :term OR u.surname LIKE :term)";
          break;
        case 3:
          $query = "SELECT u.name AS validatorName, u.surname AS validatorSurname FROM AppBundle:Entry e LEFT JOIN e.validators u WHERE u.name LIKE :term OR u.surname LIKE :term";
          break;
        case 4:
          $query = "SELECT g.name AS gene, s.name AS synonym FROM AppBundle:Entry e LEFT JOIN AppBundle:Gene g WITH e.gene = g.id LEFT JOIN g.synonyms s WHERE (g.name LIKE :term OR s.name LIKE :term) ";
          break;
        case 6:
          $query = "SELECT p.description AS description FROM AppBundle:Entry e LEFT JOIN AppBundle:ComplexTrait cpt WITH cpt.entry = e LEFT JOIN AppBundle:PhenotypeTrait p WITH cpt.phenotypeTrait = p.id  WHERE p.description LIKE :term";
          break;
        case 7:
          $query = "SELECT p.category AS category FROM AppBundle:Entry e LEFT JOIN AppBundle:ComplexTrait cpt WITH cpt.entry = e LEFT JOIN AppBundle:PhenotypeTrait p WITH cpt.phenotypeTrait = p.id  WHERE p.category LIKE :term ";
          break;
        case 8:
          $query = "SELECT ta.taxId AS taxAID, tb.taxId AS taxBID FROM AppBundle:Entry e LEFT JOIN AppBundle:ComplexTaxon cta WITH cta.entryAsTaxonA = e LEFT JOIN AppBundle:Taxon ta WITH cta.taxon = ta.id LEFT JOIN AppBundle:ComplexTaxon ctb WITH ctb.entryAsTaxonB = e LEFT JOIN AppBundle:Taxon tb WITH ctb.taxon = tb.id  WHERE (ta.taxId LIKE :term OR tb.taxId LIKE :term) ";
          break;
        case 9:
          $query = "SELECT ta.latinName AS latinAName, ta.commonName AS commonAName, ta.latinName AS latinBName, ta.commonName AS commonBName FROM AppBundle:Entry e LEFT JOIN AppBundle:ComplexTaxon cta WITH cta.entryAsTaxonA = e LEFT JOIN AppBundle:Taxon ta WITH cta.taxon = ta.id LEFT JOIN AppBundle:ComplexTaxon ctb WITH ctb.entryAsTaxonB = e LEFT JOIN AppBundle:Taxon tb WITH ctb.taxon = tb.id LEFT JOIN ta.synonyms tas LEFT JOIN tb.synonyms tbs WHERE (ta.name LIKE :term OR tb.name LIKE :term OR tas.name LIKE :term OR tbs.name LIKE :term) ";
          break;
        case 10:
          $query = "SELECT e.taxonomicStatus AS taxonomic FROM AppBundle:Entry e WHERE e.taxonomicStatus LIKE :term ";
          break;
        case 11:
          $query = "SELECT m.experimentalEvidence AS experimental FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e WHERE m.experimentalEvidence LIKE :term";
          break;
        case 12:
          $query = "SELECT m.molecularDetails AS details FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e WHERE m.molecularDetails LIKE :term";
          break;
        case 13:
          $query = "SELECT m.molecularType AS molecular FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e WHERE m.molecularType LIKE :term";
          break;
        case 14:
          $query = "SELECT m.snp AS SNP FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e WHERE m.snp LIKE :term ";
          break;
        case 15:
          $query = "SELECT m.aberrationType AS aberrationType FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e WHERE m.aberrationType LIKE :term ";
          break;
        case 16:
          $query = "SELECT ro.articleTitle AS otherArticle, rm.articleTitle AS article FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e LEFT JOIN AppBundle:Reference rm WITH m.mainReference = rm.id LEFT JOIN AppBundle:MutationReference mr WITH mr.mutation = m LEFT JOIN AppBundle:Reference ro WITH mr.reference = ro WHERE (rm.articleTitle LIKE :term OR ro.articleTitle LIKE :term) ";
          break;
        case 17:
          $query = "SELECT rma.lastname AS mainAuthor, roa.lastname AS otherAuthor FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e LEFT JOIN AppBundle:Reference rm WITH m.mainReference = rm.id LEFT JOIN AppBundle:MutationReference mr WITH mr.mutation = m LEFT JOIN AppBundle:Reference ro WITH mr.reference = ro LEFT JOIN rm.authors rma  LEFT JOIN ro.authors roa WHERE (rma.lastname LIKE :term OR roa.lastname LIKE :term) ";
          $maxResults = 200;
          $groupBy = ' GROUP BY mainAuthor, otherAuthor';
          break;
        case 18:
          $query = "SELECT rm.journalYear AS year FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e LEFT JOIN AppBundle:Reference rm WITH m.mainReference = rm.id WHERE rm.journalYear LIKE :term ";
          break;
        case 19:
          $query = "SELECT rm.abstract AS abstract FROM AppBundle:Entry e LEFT JOIN AppBundle:Mutation m WITH m.entry = e LEFT JOIN AppBundle:Reference rm WITH m.mainReference = rm.id WHERE rm.abstract LIKE :term";
          break;
        case 20:
          $query = "SELECT goM.goId AS goMID, goB.goId AS goBID, goC.goId AS goCID FROM AppBundle:Entry e LEFT JOIN AppBundle:Gene g WITH e.gene = g.id LEFT JOIN g.goMolecular goM LEFT JOIN g.goBiological goB LEFT JOIN g.goCellular goC  WHERE (goM.goId LIKE :term OR goB.goId LIKE :term OR goC.goId LIKE :term OR goM.description LIKE :term OR goB.description LIKE :term OR goC.description LIKE :term) ";
          break;
        case 21:
          $query = "SELECT g.uniProtKbId AS uniProtKbID FROM AppBundle:Entry e LEFT JOIN AppBundle:Gene g WITH e.gene = g.id  WHERE g.uniProtKbId LIKE :term";
          break;
        case 22:
          $query = "SELECT e.gepheId AS gepheID FROM AppBundle:Entry e WHERE e.gepheId LIKE :term ";
          break;
        case 23:
          $query = "SELECT e.genbankId AS genbank FROM AppBundle:Entry e WHERE e.genbankId LIKE :term";
          break;
        case 25:
          $query = "SELECT e.geneGephebase AS geneGephebase FROM AppBundle:Entry e WHERE e.geneGephebase LIKE :term";
          break;
        case 24:
          // TODO HERE PUBLICATION DATE
          $query = "SELECT e.geneGephebase AS geneGephebase FROM AppBundle:Entry e WHERE e.geneGephebase LIKE :term";
          break;
        case 27:
          $query = "SELECT ta.latinName AS latinAName, ta.commonName AS commonAName, ta.taxId AS taAID FROM AppBundle:Entry e LEFT JOIN AppBundle:ComplexTaxon cta WITH cta.entryAsTaxonA = e LEFT JOIN AppBundle:Taxon ta WITH cta.taxon = ta.id  WHERE (ta.name LIKE :term OR ta.taxId LIKE :term)";
          break;
        case 28:
          $query = "SELECT tb.latinName AS latinBName, tb.commonName AS commonBName, tb.taxId AS tbBID FROM AppBundle:Entry e LEFT JOIN AppBundle:ComplexTaxon ctb WITH ctb.entryAsTaxonB = e LEFT JOIN AppBundle:Taxon tb WITH ctb.taxon = tb.id  WHERE (tb.name LIKE :term OR tb.taxId LIKE :term)";
          break;
      }
      if($field == 2) {
        $sql = $em->createQuery($query)->setParameters(array('term' => '%'.$term.'%', 'curator' => '%CURATOR%'))->getScalarResult();
      } else {
        if($sc->isGranted('ROLE_CURATOR')) {
          $query .= " AND (e.status = :status OR e.status = :statusAcceptedValidator OR e.status = :statusRefusedValidator OR e.status = :statusImported OR e.status = :statusTemporary)" . $groupBy;
          $sql = $em->createQuery($query)->setParameters(array('term' => '%'.$term.'%','status' => EntryStatus::ACCEPTED_CURATOR, 'statusRefusedValidator' => EntryStatus::REFUSED_VALIDATOR, 'statusAcceptedValidator' => EntryStatus::ACCEPTED_VALIDATOR, 'statusTemporary' => EntryStatus::TEMPORARY, 'statusImported' => EntryStatus::IMPORTED))->getScalarResult();
        } else {
          $query .= " AND (e.status = :status OR e.status = :statusAcceptedValidator OR e.status = :statusRefusedValidator)" . $groupBy;
          $sql = $em->createQuery($query)->setParameters(array('term' => '%'.$term.'%','status' => EntryStatus::ACCEPTED_CURATOR, 'statusRefusedValidator' => EntryStatus::REFUSED_VALIDATOR, 'statusAcceptedValidator' => EntryStatus::ACCEPTED_VALIDATOR))->setMaxResults(20)->getScalarResult();
        }
      }
      
      return $sql;
    }

    public function advancedSearch($search, $sc)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        $results = array();

        foreach ($search->getSearchCriterias() as $criteria) {
            $field = $criteria->getField();
            $term = $criteria->GetTerm();
            $operator = $criteria->getOperator();
            if ($field === 0) {
                $results[] = array('operator' => $operator, 'results' => $this->searchAll($term, $sc, $operator, $search->isMutationSearch()));
            } else {
                $result = $this->searchByCriteria($criteria, $sc, $search->isMutationSearch());

                // check that result is an array (no error in criteria query)
                if ($result !== null) {
                    $results[] = array('operator' => $operator, 'results' => $result);
                } else {
                    return array();
                }
            }
        }

        // First, we need to intersect all and & not operators since they have precedence
        $count = count($results);
        for ($i=1;$i<$count;$i++) {
            if ($results[$i]['operator'] !== 'or') {
                $results[$i]['results'] = array_uintersect($results[$i]['results'], $results[$i-1]['results'], function($id1, $id2) {
                    return strcmp($id1['id'], $id2['id']);
                });

                unset($results[$i-1]);
            }
        }

        $finalResults = array();
        foreach ($results as $result) {
            foreach ($result['results'] as $entry) {
                if (!in_array($entry['id'], $finalResults)) {
                    $finalResults[] = $entry['id'];
                }
            }
        }

        return $finalResults;
    }

    public function searchByCriteria($criteria, $sc, $isMutationSearch = false)
    {
        $field = $criteria->getField();
        $operator = $criteria->getOperator();
        $term = $criteria->getTerm();

        $searchableFields = Entry::getSearchableFields();

        if (!array_key_exists($field, $searchableFields)) {
            return null;
        }

        $searchField = $searchableFields[$field];

        $count_quotes = substr_count($term, '"');

        if($count_quotes > 0) {
            $term = trim(str_replace('"', "", $term));
        }

        $exactMatches = array(14, 15, 11, 1, 10, 11, 13, 27, 28, 29, 30);
        if (in_array($field, $exactMatches) || $this->isExactSearch($term)) {
            if ($this->isExactSearch($term)) {
                $term = str_replace(self::EXACT_SEARCH_CHAR, '', $term);
            }
            $searchTerm = $term;
        } elseif ($field === 22) {
            if (strtolower(substr($term, 0, 2)) === 'gp') {
                $searchTerm = $term;
            }  else {
                $searchTerm = NewEntryListener::generateGepheId($term);
            }
        } else {
            // '*' is a wildcard
            if(strpos($term, '*') !== false) {
                $term = str_replace('*', '%', $term);
            }
            $searchTerm = '%'.$term.'%';
        }

        //taxon search is an exception because we need to recursively search through the taxon lineage (all parents)
        if ($field === 8) {
            return $this->searchTaxonIdLineage($searchTerm, $operator, $sc, $isMutationSearch);
        }

        $selector = 'e.id';
        if ($isMutationSearch) {
            $selector = 'm.id';
        }

        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select($selector)
            ->from('AppBundle:Entry', 'e')
            ->where('e.status = :status')
            ->orWhere('e.status = :statusAcceptedValidator')
            ->orWhere('e.status = :statusRefusedValidator')   
            ->setParameter('value', $searchTerm)
            ->setParameter('status', EntryStatus::ACCEPTED_CURATOR)
            ->setParameter('statusAcceptedValidator', EntryStatus::ACCEPTED_VALIDATOR)
            ->setParameter('statusRefusedValidator', EntryStatus::REFUSED_VALIDATOR);


        if($sc->isGranted('ROLE_CURATOR')) {
            $qb
                ->orWhere('e.status = :statusImported')
                ->orWhere('e.status = :statusTemporary')
                ->setParameter('statusImported', EntryStatus::IMPORTED)
                ->setParameter('statusTemporary', EntryStatus::TEMPORARY);

        }

        /*  
            if we have an operator not we must build a subquery and substract the rows of the opposite request
            indeed, the left join in the reference table for example can return ENTRY rows
            if we say AND NOT author='Tata' and we have 3 rows in ENTRY and one is Tata and the others are Toto we will have 2 rows
            and we group by with ENTRY so in spite the condition the ENTRY will be displayed
            
            Example with criteria AND NOT Author Letay : 

            SELECT * FROM entry e0_
            LEFT JOIN reference r1_ ON (e0_.main_reference = r1_.id)
            LEFT JOIN reference_author r3_ ON r1_.id = r3_.reference_id
            LEFT JOIN author a2_ ON a2_.id = r3_.author_id
            LEFT JOIN entry_reference e5_ ON e0_.id = e5_.entry_id
            LEFT JOIN reference r4_ ON r4_.id = e5_.reference_id
            LEFT JOIN reference_author r7_ ON r4_.id = r7_.reference_id
            LEFT JOIN author a6_ ON a6_.id = r7_.author_id
            WHERE (e0_.status_id = 1 OR e0_.status_id = 2 OR e0_.status_id = 5 OR e0_.status_id = 4 OR e0_.status_id = 3)
            AND ((a2_.lastname NOT LIKE "%Letay%" OR a2_.lastname IS NULL)
            AND (a6_.lastname NOT LIKE "%Letay%" OR a6_.lastname IS NULL))

            and e0_.id not in
            (
                SELECT e1_.id FROM entry e1_
                LEFT JOIN reference r1_ ON (e1_.main_reference = r1_.id)
                LEFT JOIN reference_author r3_ ON r1_.id = r3_.reference_id
                LEFT JOIN author a2_ ON a2_.id = r3_.author_id
                LEFT JOIN entry_reference e5_ ON e1_.id = e5_.entry_id
                LEFT JOIN reference r4_ ON r4_.id = e5_.reference_id
                LEFT JOIN reference_author r7_ ON r4_.id = r7_.reference_id
                LEFT JOIN author a6_ ON a6_.id = r7_.author_id
                WHERE (e1_.status_id = 1 OR e1_.status_id = 2 OR e1_.status_id = 5 OR e1_.status_id = 4 OR e1_.status_id = 3)
                AND (a2_.lastname LIKE "%Letay%" OR a6_.lastname LIKE "%Letay%" ) GROUP BY e1_.id ORDER BY e1_.id DESC 
            )

            GROUP BY e0_.id ORDER BY e0_.id DESC

        */
        if ($operator === 'not') {

            $notSelector = 'e1.id';
            if ($isMutationSearch) {
                $notSelector = 'muniqueToken.id';
            }

            $qbNot = $this->getEntityManager()->createQueryBuilder();

            $qbNot->select($notSelector)
                ->from('AppBundle:Entry', 'e1')
                ->where('e1.status = :status')
                ->orWhere('e1.status = :statusAcceptedValidator')
                ->orWhere('e1.status = :statusRefusedValidator')
                ->orderBy('e1.id', 'DESC')
                ->groupBy($notSelector)
                ->setParameter('value', $searchTerm)
                ->setParameter('status', EntryStatus::ACCEPTED_CURATOR)
                ->setParameter('statusAcceptedValidator', EntryStatus::ACCEPTED_VALIDATOR)
                ->setParameter('statusRefusedValidator', EntryStatus::REFUSED_VALIDATOR);

            if($sc->isGranted('ROLE_CURATOR')) {

                $qbNot
                    ->orWhere('e1.status = :statusImported')
                    ->orWhere('e1.status = :statusTemporary')
                    ->setParameter('statusImported', EntryStatus::IMPORTED)
                    ->setParameter('statusTemporary', EntryStatus::TEMPORARY);
            }
        }

        $queryOperator = 'LIKE';
        $queryOperatorTmp = 'NOT LIKE';
        $orX = $qb->expr()->orX();
        $orXNot = $qb->expr()->orX();
        if ($operator === 'not') {
            $queryOperator = 'NOT LIKE';
            $queryOperatorTmp = 'LIKE';
            $orX = $qb->expr()->andX();
            $orXNot = $qb->expr()->orX();
        }

        // handle publication date special case
        if ($field == 29) {
          if ($queryOperator == 'LIKE') {
            $queryOperator = '>=';
            $queryOperatorTmp = '<';
          } else {
            $queryOperator = '<';
            $queryOperatorTmp = '>=';
          }
        }

        if ($field == 30) {
          if ($queryOperator == 'LIKE') {
            $queryOperator = '<=';
            $queryOperatorTmp = '>';
          } else {
            $queryOperator = '<=';
            $queryOperatorTmp = '>';
          }
        }

        // add a unique suffix token named uniqueToken for subquery required for the AND NOT
        $tokenAlias = 'uniqueToken';

        foreach ($searchField as $table) {
            if ($table['type'] === 'toOne') {
                $qb->leftJoin('AppBundle:'.$table['table'], $table['shorthand'], 'WITH', $table['joinColumn'] . ' = ' . $table['referenceColumn']);

                // if the prefix is not e, we had the token else the suffix is the alias for the not query so e1
                $prefix = substr($table['joinColumn'], 0, strpos($table['joinColumn'], '.'));
                if ($prefix !== 'e') {
                    $prefix = $prefix . $tokenAlias;
                } else {
                    $prefix = 'e1';
                }

                if ($operator === 'not') {
                    // same for the referenceColumn
                    if ($pos = strpos($table['referenceColumn'], '.')) {
                        $prefix2 = substr($table['referenceColumn'], 0, $pos);
                    } else {
                        $prefix2 = $table['referenceColumn'];
                    }

                    if ($prefix2 !== 'e') {
                        $prefix2 = $prefix2 . $tokenAlias;
                    } else {
                        $prefix2 = 'e1';
                    }

                    $qbNot->leftJoin('AppBundle:'.$table['table'], $table['shorthand'].$tokenAlias, 'WITH', $prefix . strstr($table['joinColumn'], '.') . ' = ' . $prefix2 . strstr($table['referenceColumn'], '.'));
                }

            } elseif ($table['type'] === 'toMany') {
                $qb->leftJoin($table['joinColumn'], $table['shorthand']);

                if ($operator === 'not') {

                    $prefix = substr($table['joinColumn'], 0, strpos($table['joinColumn'], '.'));
                    if ($prefix !== 'e'){
                        $prefix = $prefix . $tokenAlias;
                    } else {
                        $prefix = 'e1';
                    }

                    $qbNot->leftJoin($prefix . strstr($table['joinColumn'], '.'), $table['shorthand'].$tokenAlias);
                }
            }

            if (!array_key_exists('searchFields', $table)) {
                continue;
            }
            foreach ($table['searchFields'] as $field) {
                $orXContent = $table['shorthand'].'.'.$field.' '.$queryOperator.' :value';
                            
                if ($operator == 'not') {
                    $innerOrX = $qb->expr()->orX();
                    $innerOrX->add($orXContent);
                    $innerOrX->add($table['shorthand'].'.'.$field.' IS NULL');
                    $orX->add($innerOrX);

                    $notShorthand = $table['shorthand'];
                    if ($table['shorthand'] !== 'e') {
                        $notShorthand = $table['shorthand'] . $tokenAlias;
                    }

                    $orXContentTmp = $notShorthand.'.'.$field.' '.$queryOperatorTmp.' :value';

                    $innerOrXTmp = $qb->expr()->orX();
                    $innerOrXTmp->add($orXContentTmp);
                    $orXNot->add($innerOrXTmp);

                } else {
                    $orX->add($orXContent);
                }
            }

        }

        $qb->andWhere($orX);
        // if it's a search split by mutations, we need to make sure that the join exists on the querybuilder
        if ($isMutationSearch) {
          $qb = $this->addMutationJoin($qb);
          if ($operator == 'not') {
            $qbNot = $this->addMutationJoin($qbNot, 'muniqueToken', 'e1');
          }
        }

        // if operator not, we add the not in subquery to the main query
        if ($operator == 'not') {
            $qbNot->andWhere($orXNot);
            $qb->andWhere($qb->expr()->notIn($selector, $qbNot->getDql()));
        }


        $qb
          ->orderBy($selector, 'DESC')
          ->groupBy($selector);

        return $qb->getQuery()->getResult();
    }

    public function retrieveAllData($ids, $search = null, $searchBuilder = null)
    {
        if (empty($ids)) {
            return array();
        }

        $idType = 'e.id';
        $isMutationSearch = false;
        if ($search && $search->isMutationSearch()) {
            $isMutationSearch = true;
            $idType = 'm.id';
        }

        $ids = array_unique($ids);

        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id')
            ->addSelect('e.geneGephebase')
            ->addSelect('e.gepheId')
            ->addSelect('g.uniProtKbId')
            ->addSelect('g.name as geneName')
            ->addSelect('e.taxonomicStatus')
            ->addSelect('e.ancestralState')
            ->addSelect('m.id as mid')
            ->addSelect('m.experimentalEvidence')
            ->addSelect('m.molecularType')
            ->addSelect('m.aberrationType')
            ->addSelect('m.presumptiveNull')
            ->addSelect('m.experimentalEvidence')
            ->addSelect('m.molecularDetails')
            ->addSelect('rm.journalYear')
            ->addSelect('rm.pmId')
            ->addSelect('rm.articleTitle')
            ->addSelect('c.username')
            ->addSelect('v.surname')
            ->addSelect('v.name')
            ->addSelect('co.username AS othersUsername')
            ->addSelect('es.name as status')
            ->addSelect('e.commentsValidator')
            ->addSelect('e.dateEmail')
            ->addSelect('m.tempDateValidation')
            ->addSelect('m.dateEmail as mDateEmail')
            ->addSelect('count(m.id)')
            ->from('AppBundle:Entry', 'e')
            ->leftJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->leftJoin('AppBundle:Gene','g','WITH', 'e.gene = g')
            ->leftJoin('AppBundle:Mutation', 'm', 'WITH', 'm.entry = e')
            ->leftJoin('AppBundle:Reference', 'rm', 'WITH', 'm.mainReference = rm')
            ->leftJoin('AppBundle:User', 'c', 'WITH', 'e.mainCurator = c')
            ->leftJoin('e.validators', 'v')
            ->leftJoin('e.otherCurators', 'co')
            ->groupBy($idType)
            ->where($idType .' IN ( '.implode(',', array_map('intval',$ids)).' )');

        $query = $qb->getQuery();


        try
        {
            $entries = $query->getResult();

            $traits = $this->findAllTraits();
            $taxonAs = $this->findAllTaxons('A');
            $taxonBs = $this->findAllTaxons('B');
            $authors = $this->findAllAuthors();
            $curators = $this->findAllCurators();

            if ($isMutationSearch) {
                $others = $this->findAllOtherReferencesInfos($authors);
            } else {
                // if it's not a mutation search, get other references grouped by entryId
                $others = $this->findAllOtherReferencesInfos($authors, true);
            }

            $othersByMutation = $this->findAllOtherReferencesInfos($authors);
            $othersByEntry = $this->findAllOtherReferencesInfos($authors, true);

            foreach ($entries as $key => $entry) {
                // add traits to array
                $this->addCollectionItemToEntryArray('traits', $traits, $entry, $key, $entries);
                // add taxon As to array
                $this->addCollectionItemToEntryArray('taxonA', $taxonAs, $entry, $key, $entries);
                // add taxon Bs to array
                $this->addCollectionItemToEntryArray('taxonB', $taxonBs, $entry, $key, $entries);
                // add curators to array
                $this->addCollectionItemToEntryArray('curators', $curators, $entry, $key, $entries);
                // add taxon As to array
                $this->addCollectionItemToEntryArray('authors', $authors, $entry, $key, $entries, 'pmId');
                // add others references to array
                $this->addCollectionItemToEntryArray('others', $others, $entry, $key, $entries, 'others', $isMutationSearch);
            }

            if ($search && $search->getGroupHaplotypes()) {
                $entries = $this->groupByMutations($entries, $search, $searchBuilder);
                $alreadyDone = array();
                $entriesTemp = $entries;
                foreach($entries as $key => $entry) {
                    foreach($entriesTemp as $keyTemp => $entryTemp) {
                        if($key != $keyTemp && $entry['id'] == $entryTemp['id'] && !in_array($entry['id'], $alreadyDone)) {
                            unset($entries[$key]);
                            $alreadyDone[] = $entry['id'];
                        }
                    }
                }

            } else if ($search && $search->getGroupGenes()) {
              $entries = $this->groupByGenes($entries, $search, $searchBuilder);
            } else if ($search && $search->getSplitMutations()) {
              $mutationIds = [];
              foreach ($entries as &$entry) {
                $entry['mutationList'][] = $entry['mid'];
              }
            } else {
                //IF THIS IS A DEFAULT SEARCH(neither "groupByGenes" nor "groupByMutations" ),
                //WE RETRIEVE NUMBER OF MUTATIONS and COMMON VALUES FOR DEFAULT SEARCH TEMPLATE
                // KRA: this needs to be optimised, using IN ('ids') to limit the db queries to 1.

                $commonMutations = [];
                foreach ($ids as $id) {
                    $commonMutations[] = $this->createQueryBuilder('e')
                        ->leftJoin('e.mutations', 'm')
                        ->andWhere('m.entry = :id')
                        ->setParameter('id', $id)
                        ->select('e.id')
                        ->addSelect('m.molecularType')
                        ->addSelect('m.aberrationType')
                        ->addSelect('m.presumptiveNull')
                        ->addSelect('m.id as mid')
                        ->getQuery()
                        ->getResult();
                }

                $mutationList = [];
                $entriesIds = [];
                foreach ($commonMutations as $mutations) {
                    foreach ($mutations as $mutation) {
                        if (array_key_exists('id', $mutation) ) {
                            $entriesIds[] = $mutation['id'];
                        }
                        $mutationList[$mutation['id']][] = $mutation['mid'];
                    }
                }


                //We retrieve ids of all arrays having more than 1 mutation
                $countIds = array_count_values($entriesIds);

                $mutationsData = [];
                foreach ($countIds as $id => $numberMutations ) {
                    foreach ($entries as $entry) {
                        if (1 < $numberMutations && $entry['id'] === $id) {

                            $mutationsData['mutations'][$id]['numberOfMutations'] = $numberMutations;

                            foreach ($commonMutations as $mutations) {
                                foreach ($mutations as $mutation) {
                                    foreach ($mutation as $index => $value)
                                        if ($entry['id'] === $mutation['id'] && array_key_exists($index, $mutation) && $index !== 'id') {

                                            $mutationsData['mutations'][$id]['values'][$index][] = $value;

                                    }
                                }
                            }
                        }
                    }
                }
                if (isset($mutationsData['mutations'])) {
                    foreach ($mutationsData['mutations'] as $id => $entry) {
                        foreach ($entry['values'] as $type => $values) {
                            $commonValues[$type] = array_count_values($values);

                            foreach ($commonValues[$type] as $value => $count) {

                                if ($count === $mutationsData['mutations'][$id]['numberOfMutations'] ) {
                                    $mutationsData['mutations'][$id]['values'][$type]['isCommon'] = true;
                                } else {
                                    $mutationsData['mutations'][$id]['values'][$type]['isCommon'] = false;
                                }
                            }
                        }
                    }
                }

                foreach ($mutationsData as $datas) {
                    foreach ($datas as $id => $data) {
                        foreach ($entries as $index => $entry) {
                            if ($entry['id'] === $id) {
                                $entries[$index]['mutationList'] = $mutationList[$id];
                                $entries[$index]['datas'] = $data;
                            }
                        }
                    }
                }

            }

            return $entries;
        }
        catch (\Doctrine\ORM\NoResultException $e)
        {
            return null;
        }
    }

    public function validatorsByEntries() {
      $em = $this->getEntityManager();
      $temp = new \DateTime();
      $interval = new \DateInterval('P1M');//1 month
      $last = $temp->sub($interval);
      $sql = $em->createQuery("SELECT e FROM AppBundle:Entry e INNER JOIN AppBundle:EntryStatus es WHEN e.status = es WHERE e.validators IS NOT empty AND es.id = :status AND ((e.tempDateValidation IS NOT NULL AND e.dateEmail < :last AND e.dateEmail IS NOT NULL) OR (e.tempDateValidation IS NOT NULL AND e.dateEmail IS NULL)) ")->setParameters(array('last' => $last, 'status' => EntryStatus::ACCEPTED_CURATOR))->getResult();

      return $sql;
    }

    public function findAllByTraits($term) {
      $em = $this->getEntityManager();
      $qb = $em->createQueryBuilder()
            ->select('e')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTrait', 'cpt', 'WITH', 'cpt.entry = e')
            ->innerJoin('AppBundle:PhenotypeTrait', 'pt', 'WITH', 'cpt.phenotypeTrait = pt')
            ->where('pt.description LIKE :term')
            ->setParameter('term', '%'.$term.'%');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            return $results;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    public function findAllByTraitCategory($term) {
      $em = $this->getEntityManager();
      $qb = $em->createQueryBuilder()
            ->select('e')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTrait', 'cpt', 'WITH', 'cpt.entry = e')
            ->innerJoin('AppBundle:PhenotypeTrait', 'pt', 'WITH', 'cpt.phenotypeTrait = pt')
            ->where('pt.category LIKE :term')
            ->setParameter('term', '%'.$term.'%');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            return $results;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    public function findAllByGeneName($term) {
      $em = $this->getEntityManager();
      $sql = $em->createQuery("SELECT e FROM AppBundle:Entry e INNER JOIN AppBundle:Gene g WHEN e.gene = g.id INNER JOIN g.synonyms s WHERE s.name LIKE :term OR e.geneGephebase LIKE :term OR g.name LIKE :term")->setParameter('term', '%'.$term.'%')->getResult();
      return $sql;
    }

    public function findAllByTaxon($term) {
      
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTaxon', 'cta', 'WITH', 'cta.entryAsTaxonA = e')
            ->innerJoin('AppBundle:ComplexTaxon', 'ctb', 'WITH', 'ctb.entryAsTaxonA = e')
            ->innerJoin('AppBundle:Taxon', 'ta', 'WITH', 'cta.taxon = ta')
            ->innerJoin('AppBundle:Taxon', 'tb', 'WITH', 'ctb.taxon = tb')
            ->where('ta.name LIKE :term')
            ->orWhere('ta.latinName LIKE :term')
            ->orWhere('ta.commonName LIKE :term')
            ->orWhere('ta.rank LIKE :term')
            ->orWhere('tb.name LIKE :term')
            ->orWhere('tb.latinName LIKE :term')
            ->orWhere('tb.commonName LIKE :term')
            ->orWhere('tb.rank LIKE :term')
            ->setParameter('term', '%'.$term.'%');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            return $results;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    public function findAllByGephe($entries) {
      $em = $this->getEntityManager();
      $sql = $em->createQuery('SELECT e FROM AppBundle:Entry e WHERE e.id IN ('.implode(',', array_map('intval',$entries)).')')->getResult();
      return $sql;
    }

    public function findAllByExperimental($term) {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:Mutation', 'm', 'WITH', 'm.entry = e')
            ->where('m.experimentalEvidence LIKE :term')
            ->setParameter('term', '%'.$term.'%');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            return $results;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    private function sortByGepheId($a, $b)
    {
      if ($a->getGepheId() < $b->getGepheId()) {
        return -1;
      } else {
        return 1;
      }
    }

    /**
     * Find gene gephebase by filter
     */
    public function filterGeneGephebase($filters)
    {

        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.gepheId, e.geneGephebase, g.name, cta.description as taxA, ctb.description as taxB, pt.description as trait, pt.category')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:Gene', 'g', 'WITH', 'e.gene = g')
            ->innerJoin('AppBundle:ComplexTaxon', 'cta', 'WITH', 'cta.entryAsTaxonA = e')
            ->innerJoin('AppBundle:ComplexTaxon', 'ctb', 'WITH', 'ctb.entryAsTaxonB = e')
            ->innerJoin('AppBundle:ComplexTrait', 'ct', 'WITH', 'ct.entry = e')
            ->innerJoin('AppBundle:PhenotypeTrait', 'pt', 'WITH', 'ct.phenotypeTrait = pt')
            ->groupBy('e.id');

        $gepheId = $filters['gepheId'];
        if ($gepheId && trim($gepheId) !== "") {
            $qb->andWhere('e.gepheId LIKE :gepheId');
            $qb->setParameter('gepheId', "%".$gepheId."%");
        }

        $geneGephebase = $filters['geneGephebase'];
        if ($geneGephebase && trim($geneGephebase) !== "") {
            $qb->andWhere('e.geneGephebase LIKE :geneGephebase');
            $qb->setParameter('geneGephebase', "%".$geneGephebase."%");
        }

        $gene = $filters['gene'];
        $geneName = $gene->getName();
        if ($geneName && trim($geneName) !== "") {
            $qb->andWhere('g.name LIKE :geneName');
            $qb->setParameter('geneName', "%".$geneName."%");
        }

        $taxonA = $filters['taxonADescription'];
        if ($taxonA && trim($taxonA) !== "") {
            $qb->andWhere('cta.description LIKE :taxonA');
            $qb->setParameter('taxonA', "%".$taxonA."%");
        }

        $taxonB = $filters['taxonBDescription'];
        if ($taxonB && trim($taxonB) !== "") {
            $qb->andWhere('ctb.description LIKE :taxonB');
            $qb->setParameter('taxonB', "%".$taxonB."%");
        }

        $trait = $filters['phenotypeTrait'];
        $description = $trait->getDescription();
        if ($description && trim($description) !== "") {
            $qb->andWhere('pt.description LIKE :description');
            $qb->setParameter('description', "%".$description."%");
        }
        $category = $trait->getCategory();
        if ($category && trim($category) !== "") {
            $qb->andWhere('pt.category LIKE :category');
            $qb->setParameter('category', "%".$category."%");
        }

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    /**
     * Find UniprotKB  by filter
     */
    public function filterUniprotkb($filters)
    {

        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.gepheId, e.geneGephebase, g.name, g.uniProtKbId as uniprotkbid')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:Gene', 'g', 'WITH', 'e.gene = g')
            ->groupBy('e.id');

        $gepheId = $filters['gepheId'];
        if ($gepheId && trim($gepheId) !== "") {
            $qb->andWhere('e.gepheId LIKE :gepheId');
            $qb->setParameter('gepheId', "%".$gepheId."%");
        }

        $geneGephebase = $filters['geneGephebase'];
        if ($geneGephebase && trim($geneGephebase) !== "") {
            $qb->andWhere('e.geneGephebase LIKE :geneGephebase');
            $qb->setParameter('geneGephebase', "%".$geneGephebase."%");
        }

        $gene = $filters['gene'];
        $geneName = $gene->getName();
        if ($geneName && trim($geneName) !== "") {
            $qb->andWhere('g.name LIKE :geneName');
            $qb->setParameter('geneName', "%".$geneName."%");
        }
        $uniprotkb = $gene->getUniProtKbId();
        if ($uniprotkb && trim($uniprotkb) !== "") {
            $qb->andWhere('g.uniProtKbId LIKE :uniprotkb');
            $qb->setParameter('uniprotkb', "%".$uniprotkb."%");
        }


        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    /**
     * Find Genbank  by filter
     */
    public function filterGenbank($filters)
    {

        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.genbankId as genbank, e.geneGephebase, g.name, cta.description as taxA')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTaxon', 'cta', 'WITH', 'cta.entryAsTaxonA = e')
            ->innerJoin('AppBundle:Gene', 'g', 'WITH', 'e.gene = g')
            ->groupBy('e.id');

        $genbankId = $filters['genbankId'];
        if ($genbankId && trim($genbankId) !== "") {
            $qb->andWhere('e.genbankId LIKE :genbankId');
            $qb->setParameter('genbankId', "%".$genbankId."%");
        }

        $geneGephebase = $filters['geneGephebase'];
        if ($geneGephebase && trim($geneGephebase) !== "") {
            $qb->andWhere('e.geneGephebase LIKE :geneGephebase');
            $qb->setParameter('geneGephebase', "%".$geneGephebase."%");
        }

        $gene = $filters['gene'];
        $geneName = $gene->getName();
        if ($geneName && trim($geneName) !== "") {
            $qb->andWhere('g.name LIKE :geneName');
            $qb->setParameter('geneName', "%".$geneName."%");
        }

        $taxonA = $filters['taxonADescription'];
        if ($taxonA && trim($taxonA) !== "") {
            $qb->andWhere('cta.description LIKE :taxonA');
            $qb->setParameter('taxonA', "%".$taxonA."%");
        }

        $query = $qb->getQuery();

        try 
        {
            $entries = $query->getResult();

            return $entries;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    /**
     * Groups a list of entries by identical traits and taxon A and taxon B and gene-gephebase
     */
    public function groupByMutations($entries, $search, $searchBuilder)
    {
        $groupedEntries = array();

        foreach($entries as $entry) {
            if ($entry['traits']) {
                $taxonAHash = $this->generateHashFromTaxonList($entry['taxonA']);
                $taxonBHash = $this->generateHashFromTaxonList($entry['taxonB']);
                $traitHash = $this->generateHashFromTraitList($entry['traits']);
                $geneGepheHash = $entry['geneGephebase'];

                if (!isset($groupedEntries[$traitHash][$taxonAHash][$taxonBHash][$geneGepheHash])) {
                    // if the hash doesn't exist
                    $entryData = $this->createInitialDataForHash($entry, $traitHash);
                } else {    
                    $entryData = $this->incrementResultForHash($entry, $groupedEntries[$traitHash][$taxonAHash][$taxonBHash][$geneGepheHash]);

                    // create a new link to the search results that contain all grouped genes
                    $entryData['gepheLink'] = $searchBuilder->buildGroupGenesSearch($entryData, $search, true);
                }
                    
                $groupedEntries[$traitHash][$taxonAHash][$taxonBHash][$geneGepheHash] = $entryData;
            }
        }

        // flatten the hashed results
        $results = array();
        foreach ($groupedEntries as $trait) {
            foreach ($trait as $taxon) {
                foreach ($taxon as $geneGephe) {
                    foreach ($geneGephe as $entry) {
                        $results[] = $entry;
                    }
                }
            }
        }

        return $results;
    }

    /**
     * Groups a list of entries by identical traits and taxon A and taxon B
     */
    public function groupByGenes($entries, $search, $searchBuilder)
    {
        $groupedEntries = array();
        foreach($entries as $entry) {
            if ($entry['traits']) {
                $taxonAHash = $this->generateHashFromTaxonList($entry['taxonA']);
                $taxonBHash = $this->generateHashFromTaxonList($entry['taxonB']);
                $traitHash = $this->generateHashFromTraitList($entry['traits']);
                if (!isset($groupedEntries[$traitHash][$taxonAHash][$taxonBHash])) {
                    // if the hash doesn't exist
                    $entryData = $this->createInitialDataForHash($entry, $traitHash);
                } else {
                    $entryData = $this->incrementResultForHash($entry, $groupedEntries[$traitHash][$taxonAHash][$taxonBHash]);
                    // create a new link to the search results that contain all grouped genes
                    $entryData['gepheLink'] = $searchBuilder->buildGroupGenesSearch($entryData, $search);
                }
                $groupedEntries[$traitHash][$taxonAHash][$taxonBHash] = $entryData;
            }
        }

        $results = array();

        // flatten the hashed results
        foreach ($groupedEntries as $trait) {
            foreach ($trait as $taxon) {
                foreach ($taxon as $entry) {
                    $results[] = $entry;
                }
            }
        }
        return $results;
    }

    public function findIdHigherThan($id, $status) {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->where('e.id > :id')
            ->andWhere('es.id = :status')
            ->orderBy('e.id')
            ->setParameters(array('id' => $id, 'status'=> $status->getId()))
            ->setMaxResults(1);

        $query = $qb->getQuery();

        try {
            $entry = $query->getSingleResult();

            return $entry->getId();
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Initialises entry data variables for the first element for a given hash
     */
    private function createInitialDataForHash($entry, $hash)
    {
        $entryData = $entry;
        $entryData['mutationList'][] = $entry['mid'];
        $entryData['countGenes'] = 1;
        $geneName = $this->generateHashFromGeneGephebase($entry);
        $entryData['geneNames']=[$geneName];
        $entryData['countMutations'] = 1;
        $entryData['countReferences'] = 1;
        $entryData['showMutationData'] = true;
        $entryData['mainReferences'][] = $entryData['pmId'];
        $entryData['traitGroup'] = explode(';', $hash);
        $entryData['molecularTypeValue'] = [];
        $entryData['presumptiveNullValue'] = [];
        $entryData['aberrationTypeValue'] = [];
        $entryData['entryIds'][] = $entry['id'];

        return $entryData;
    }

    private function generateHashFromGeneGephebase($entry) {
        return trim(preg_replace('/(\(.*\))/', '', $entry['geneGephebase']));
    }

    /**
     * Increments entry data variables for the nth element for a given hash
     */
    private function incrementResultForHash($entry, $hash)
    {
        $entryData = $hash;
        $geneName = $this->generateHashFromGeneGephebase($entry);
        if (!in_array($geneName, $entryData['geneNames'], true)) {
            $entryData['geneNames'][] = $geneName;
            $entryData['countGenes']++;
        }
        $entryData['countMutations']++;

        // check if mutation data differs, if it does, we will show the number of mutations instead
        $mutationValues = array('aberrationType', 'molecularType', 'presumptiveNull');

        foreach ($mutationValues as $value) {
            if ($entryData[$value] !== $entry[$value]) {
                $entryData['showMutationData'] = false;
                break;
            }
        }

        //Checks whether all presumptiveNull values are the same. Second "if" statement avoids error, if there's zero common value
        if ($entryData['presumptiveNull'] === $entry['presumptiveNull']) {
            $entryData['presumptiveNullValue'][] = $entry['presumptiveNull'];
        }
        if (0 === count($entryData['presumptiveNullValue'])) {
            $entryData['presumptiveNullValue'] = [] ;
        }


        //Checks whether all molecularType values are the same
        if ($entryData['molecularType'] === $entry['molecularType']) {
            $entryData['molecularTypeValue'][] = $entry['molecularType'];
        }
        if (0 === count( $entryData['molecularTypeValue'])) {
            $entryData['molecularTypeValue'] = [] ;
        }


        //Checks whether all aberrationType values are the same
        if ($entryData['aberrationType'] === $entry['aberrationType']) {
            $entryData['aberrationTypeValue'][]  = $entry['aberrationType'];
        }
        if (0 === count($entryData['aberrationTypeValue'])) {
            $entryData['aberrationTypeValue'] = [] ;
        }


        // checks if main reference differs from all others, if it does add it to the list
        if (!in_array($entry['pmId'], $entryData['mainReferences'])) {
            $entryData['mainReferences'][] = $entry['pmId'];
        }

        // if the Evidence differs, we will display 'Mixed instead'
        if ($entryData['experimentalEvidence'] !== $entry['experimentalEvidence']) {
            $entryData['experimentalEvidence'] = 'Mixed';
        }

        $entryData['entryIds'][] = $entry['id'];
        $entryData['mutationList'][] = $entry['mid'];

        return $entryData;
    }

    /**
     * Generates a hash from an array of taxons which each contain a taxId index
     * sort the taxId and concatenate them with a semi-colon
     */
    private function generateHashFromTaxonList($taxonList)
    {
        if (!$taxonList) {
            return '';
        }
        // get all taxon and sort them
        foreach($taxonList as $taxon) {
            $taxonArray[] = $taxon['taxId'];
        }
        sort($taxonArray);
        $taxonHash = implode(";",$taxonArray);

        return $taxonHash;
    }

    /**
     * Generates a hash from an array of traits
     * sort the traits and concatenate them with a semi-colon
     */
    private function generateHashFromTraitList($traits)
    {
        if (!$traits) {
            return '';
        }

        // array that will contain cleaned up trait descriptions
        $descriptions = array();
        foreach($traits as $trait) {
            // data in parenthesis is ignored
            $descriptions[] = trim(preg_replace('/(\(.*\))/', '', $trait['description']));
        }
        // sort the array so that trait collections containing identical traits but in different orders will still match the same hash
        sort($descriptions);
        $traitHash = implode(";", $descriptions);
        return $traitHash;
    }


    /**
     * Returns a list of a traits in an array indexed by entry ID
     */
    public function findAllTraits()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, pt.description, pt.category')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTrait', 'cpt', 'WITH', 'cpt.entry = e')
            ->innerJoin('AppBundle:PhenotypeTrait', 'pt', 'WITH', 'cpt.phenotypeTrait = pt');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $traits = array();
            // index the results by entry id
            foreach ($results as $result) {
                if ($result['description']) {
                    $traits[$result['id']][] = array(
                        'description' => $result['description'],
                        'category' => $result['category'],
                    );
                }
            }

            return $traits;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of imported taxon B IDs in an array indexed by entry ID
     */
    public function findAllImportedTaxonBs()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, ct.importTaxonId')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTaxon', 'ct', 'WITH', 'ct.entryAsTaxonB = e');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $taxons = array();
            // index the results by entry id
            foreach ($results as $result) {
                if ($result['importTaxonId']) {
                    $taxons[$result['id']][] = array(
                      'unfetchedTaxonBId' => $result['importTaxonId'],
                    );
                }
            }

            return $taxons;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of complex traits in an array indexed by entry ID
     */
    public function findAllComplexTraits()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, cpt.stateInTaxonA, cpt.stateInTaxonB, pt.description, pt.category')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTrait', 'cpt', 'WITH', 'cpt.entry = e')
            ->innerJoin('AppBundle:PhenotypeTrait', 'pt', 'WITH', 'cpt.phenotypeTrait = pt');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $complexTraits = array();
            // index the results by entry id
            foreach ($results as $result) {
                $complexTraits[$result['id']][] = array(
                    'description' => $result['description'],
                    'category' => $result['category'],
                    'stateInTaxonA' => $result['stateInTaxonA'],
                    'stateInTaxonB' => $result['stateInTaxonB'],                    
                );
            }

            return $complexTraits;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of complex taxons in an array indexed by entry ID
     */
    public function findAllComplexTaxons($type)
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, ct.isInfraspecies, t.latinName, t.commonName, t.rank, t.taxId, t.lineage, ct.description')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTaxon', 'ct', 'WITH', 'ct.entryAsTaxon'.$type.' = e')
            ->innerJoin('AppBundle:Taxon', 't', 'WITH', 'ct.taxon = t');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $taxons = array();
            // index the results by entry id
            foreach ($results as $result) {
              $taxons[$result['id']][] = array(
                  'latinName' => $result['latinName'],
                  'commonName' => $result['commonName'],
                  'rank' => $result['rank'],
                  'taxId' => $result['taxId'],
                  'isInfraspecies' => $result['isInfraspecies'],
                  'lineage' => $result['lineage'],
                  'description' => $result['description']
              );
            }

            return $taxons;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of GO in an array indexed by gene ID
     * acceptable types are: goMolecular, goBiological and goCellular
     */
    public function findAllGo($type)
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('g.id as geneId, go.goId as goId')
            ->from('AppBundle:Gene', 'g')
            ->innerJoin('g.'.$type, 'go');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $gos = array();
            // index the results by gene id
            foreach ($results as $result) {
              $gos[$result['geneId']][] = $result['goId'];
            }
            return $gos;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of synonyms in an array indexed by gene ID
     */
    public function findAllSynonyms()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('g.id as geneId, s.name')
            ->from('AppBundle:Gene', 'g')
            ->innerJoin('g.synonyms', 's');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $synonyms = array();
            // index the results by gene id
            foreach ($results as $result) {
              $synonyms[$result['geneId']][] = $result['name'];
            }

            return $synonyms;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of mutations in an array indexed by entry ID
     */
    public function findAllMutations()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, m.id as mutationId, m.presumptiveNull, m.molecularType, m.aberrationType, m.snp, m.aberrationSize, m.codonTaxonA, m.codonTaxonB, m.codonPosition, m.aaPosition, m.aminoAcidTaxonA, m.aminoAcidTaxonB, m.molecularDetails, m.experimentalEvidence, r.pmId, r.articleTitle, r.abstract, r.journalYear')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:Mutation', 'm', 'WITH', 'm.entry = e')
            ->leftJoin('AppBundle:Reference', 'r', 'WITH', 'm.mainReference = r');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();
            $otherReferences = $this->findAllOtherReferences();

            $mutations = array();
            // index the results by entry id
            foreach ($results as $result) {
              // look for other references in the array indexed by mutation id
              if (array_key_exists($result['mutationId'], $otherReferences)) {
                // if we find a row, concatenate all of them with a semi-colon
                $mutationOtherReferences = implode(';', $otherReferences[$result['mutationId']]);
              } else {
                // otherwise set it to empty
                $mutationOtherReferences = '';
              }

              $mutations[$result['id']][] = array(
                  'mutationId' => $result['mutationId'],
                  'presumptiveNull' => $result['presumptiveNull'],
                  'molecularType' => $result['molecularType'],
                  'aberrationType' => $result['aberrationType'],
                  'snp' => $result['snp'],
                  'aberrationSize' => $result['aberrationSize'],
                  'codonTaxonA' => $result['codonTaxonA'],
                  'codonTaxonB' => $result['codonTaxonB'],
                  'codonPosition' => $result['codonPosition'],
                  'aaPosition' => $result['aaPosition'],
                  'aminoAcidTaxonA' => $result['aminoAcidTaxonA'],
                  'aminoAcidTaxonB' => $result['aminoAcidTaxonB'],
                  'molecularDetails' => $result['molecularDetails'],
                  'experimentalEvidence' => $result['experimentalEvidence'],
                  'pmId' => $result['pmId'],
                  'articleTitle' => $result['articleTitle'],
                  'abstract' => $result['abstract'],
                  'journalYear' => $result['journalYear'],
                  'otherPmid' => $mutationOtherReferences,
              );
            }

            return $mutations;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of feedbacks in an array indexed by entry
     */
    public function findAllFeedbacks()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('f.feedback, f.email, e.id')
            ->from('AppBundle:Feedback', 'f')
            ->innerJoin('AppBundle:Entry', 'e', 'WITH', 'f.entry = e');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $feedbacks = array();
            // index the results by entry id
            foreach ($results as $result) {
              $feedbacks[$result['id']][] = array(
                  'feedback' => $result['feedback'],
              );
            }

            return $feedbacks;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of all taxons in an array indexed by entry ID
     */
    public function findAllTaxons($type)
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, t.latinName, t.commonName, t.rank, t.taxId')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('AppBundle:ComplexTaxon', 'ct', 'WITH', 'ct.entryAsTaxon'.$type.' = e')
            ->innerJoin('AppBundle:Taxon', 't', 'WITH', 'ct.taxon = t');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $taxons = array();
            // index the results by entry id
            foreach ($results as $result) {
                if ($result['latinName']) {
                    $taxons[$result['id']][] = array(
                        'latinName' => $result['latinName'],
                        'commonName' => $result['commonName'],
                        'rank' => $result['rank'],
                        'taxId' => $result['taxId'],
                    );
                }
            }

            return $taxons;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of all authors in an array indexed by reference pmId
     */
    public function findAllAuthors()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('a.lastname, a.initials, r.pmId')
            ->from('AppBundle:Reference', 'r')
            ->innerJoin('r.authors', 'a');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $authors = array();
            // index the results by reference pmId
            foreach ($results as $result) {
                if ($result['pmId']) {
                    $authors[$result['pmId']][] = $result['lastname'].' '.$result['initials'];
                }
            }

            return $authors;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of all otherReferences in an array indexed by mutation id
     */
    public function findAllOtherReferences()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('m.id, r.pmId')
            ->from('AppBundle:Mutation', 'm')
            ->innerJoin('AppBundle:MutationReference', 'mr', 'WITH', 'mr.mutation = m')
            ->innerJoin('AppBundle:Reference', 'r', 'WITH', 'mr.reference = r');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $otherReferences = array();
            // index the results by reference pmId
            foreach ($results as $result) {
                $otherReferences[$result['id']][] = $result['pmId'];
            }

            return $otherReferences;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of all otherReferences in an array indexed by mutation id
     */
    public function findAllOtherReferencesInfos($authors, $groupByEntry = false)
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('m.id, r.pmId, r.journalYear, r.articleTitle, IDENTITY(m.entry) as entryId')
            ->from('AppBundle:Mutation', 'm')
            ->innerJoin('AppBundle:MutationReference', 'mr', 'WITH', 'mr.mutation = m')
            ->innerJoin('AppBundle:Reference', 'r', 'WITH', 'mr.reference = r');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $groupByKey = 'id';
            if ($groupByEntry) {
                $groupByKey = 'entryId';
            }

            $otherReferences = array();
            // index the results by reference pmId
            foreach ($results as $result) {
                $otherReferences[$result[$groupByKey]][$result['pmId']]['pmId'] = $result['pmId'];
                $otherReferences[$result[$groupByKey]][$result['pmId']]['journalYear'] = $result['journalYear'];
                $otherReferences[$result[$groupByKey]][$result['pmId']]['articleTitle'] = $result['articleTitle'];
                if (array_key_exists($result['pmId'], $authors)) {
                  $otherReferences[$result[$groupByKey]][$result['pmId']]['authors'] = $authors[$result['pmId']];
                }
            }

            return $otherReferences;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Returns a list of all curators in an array indexed by reference pmId
     */
    public function findAllCurators()
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e.id, u.username')
            ->from('AppBundle:Entry', 'e')
            ->innerJoin('e.otherCurators', 'u');

        $query = $qb->getQuery();

        try {
            $results = $query->getResult();

            $curators = array();
            // index the results by reference pmId
            foreach ($results as $result) {
                if ($result['username']) {
                    $curators[$result['id']][] = $result['username'];
                }
            }

            return $curators;
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }

    /**
     * Adds all $type collection elements to the array $entries passed as parameter
     */
    public function addCollectionItemToEntryArray($type, $collection, $entry, $key, &$entries, $index = 'id', $mutationSearch = false)
    {
        if ($index == 'others') {

            $groupByKey = 'id';
            if ($mutationSearch) {
                $groupByKey = 'mid';
            }

            if(array_key_exists($entry[$groupByKey], $collection)) {
                $entries[$key][$type] = $collection[$entry[$groupByKey]];
            } else {
                $entries[$key][$type] = null;
            }
        } else {
            if (array_key_exists($entry[$index], $collection)) {
                $entries[$key][$type] = $collection[$entry[$index]];
            } else if ($index == 'id') {
                // if the key doesn't exist, we create empty fields for each field values
                $emptyArray = array();

                foreach($collection as $collectionItem) {
                    foreach ($collectionItem as $itemFields) {
                      $fields = array_keys($itemFields);
                      break;
                    } 

                    // exit after first element, we only need the structure of the elements
                    break;
                }

                if (isset($fields)) {
                    foreach ($fields as $field) {
                        $emptyArray[$field] = "";
                    }
                }

                $entries[$key][$type] = array($emptyArray);
            } else {
                $entries[$key][$type] = null;
            }
        }
    }

    /**
     * Returns true if the search term matches a pattern for exact search
     */
    private function isExactSearch($term)
    {
      if (substr($term, 0,1) == self::EXACT_SEARCH_CHAR && substr($term, -1) == self::EXACT_SEARCH_CHAR)
      {
        return true;
      }
    
      return false;
    }

    /**
     * Special advanced search for taxon id through the lineage
     */
    private function searchTaxonIdLineage($term, $operator, $sc, $isMutationSearch = false)
    {
        $result = array();
        $em = $this->getEntityManager();

        // replace potential search syntax characters
        $term = str_replace(array(self::EXACT_SEARCH_CHAR, '%'), '', $term);

        // first we need to find the ID of the given taxon ID
        $taxon = $em->getRepository('AppBundle:Taxon')->findOneByTaxId($term);

        if (!$taxon) {
            if ($operator == 'not') {
                return $this->searchAllEntries($sc);
            } else {
                return $result;
            }
        }

        // build the taxon tree structure
        $taxons = $em->getRepository('AppBundle:Taxon')->findAllWithParents();
        $tree = $this->createTree($taxons);

        // find the branch that contains the given taxon
        $id = $taxon->getId();
        $this->findTaxonInTree($id, $tree);
        
        // again, if it's a not operator, we have to return all results (we will not add filter at end)
        if (!$this->branch) {
            if ($operator == 'not') {
                return $this->searchAllEntries($sc);
            } else {
                return $result;
            }
        }

        // find all taxon ids in the matching branch and store them in an array
        $taxonIds = array();
        $taxonIds = $this->extractTaxonIdsFromBranch($taxonIds, $this->branch);

        $selector = 'e.id';
        if ($isMutationSearch) {
            $selector = 'm.id';
        }

        // now we can retrieve all entries that match (AND / OR operator) or don't match (NOT operator) at least one id in the list
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select($selector)
            ->from('AppBundle:Entry', 'e')
            ->leftJoin('AppBundle:ComplexTaxon', 'cta', 'WITH', 'cta.entryAsTaxonA = e')
            ->leftJoin('AppBundle:Taxon', 'ta', 'WITH', 'cta.taxon = ta')
            ->leftJoin('AppBundle:ComplexTaxon', 'ctb', 'WITH', 'ctb.entryAsTaxonB = e')
            ->leftJoin('AppBundle:Taxon', 'tb', 'WITH', 'ctb.taxon = tb')
            ->groupBy($selector)
            ->where('e.status = :status')
            ->orWhere('e.status = :statusAcceptedValidator')
            ->orWhere('e.status = :statusRefusedValidator')
            ->setParameter('taxIds', $taxonIds)
            ->setParameter('status', EntryStatus::ACCEPTED_CURATOR)
            ->setParameter('statusAcceptedValidator', EntryStatus::ACCEPTED_VALIDATOR)
            ->setParameter('statusRefusedValidator', EntryStatus::REFUSED_VALIDATOR);

        if($sc->isGranted('ROLE_CURATOR')) {
          $qb
            ->orWhere('e.status = :statusImported')
            ->orWhere('e.status = :statusTemporary')
            ->setParameter('statusImported', EntryStatus::IMPORTED)
            ->setParameter('statusTemporary', EntryStatus::TEMPORARY);

        };

        if ($operator !== 'not') {
            $orX = $qb->expr()->orX();
            $orX->add('tb.id IN (:taxIds)');
            $orX->add('ta.id IN (:taxIds)');
            $qb->andWhere($orX);
        } else {
            $orXA = $qb->expr()->orX();
            $orXA->add('ta.id NOT IN (:taxIds)');
            $orXA->add('ta IS NULL');
            $orXB = $qb->expr()->orX();
            $orXB->add('tb.id NOT IN (:taxIds)');
            $orXB->add('tb IS NULL');
            $qb->andWhere($orXA);
            $qb->andWhere($orXB);
        }

         if ($isMutationSearch) {
          $qb = $this->addMutationJoin($qb);
        }

        $result = $qb->getQuery()->getResult();

        return $result;
    }

    /**
     * builds a tree structure from a flat array using "parent" key
     */
    private function createTree($flatArray, $root = "")
    {
        $parents = array();
        foreach ($flatArray as $node) {
            $parents[$node['parent']][] = $node;
        }

        return $this->createBranch($parents, $parents[""]);
    }

    /**
     * Builds a single branch of a tree structure
     */
    private function createBranch(&$parents, $children)
    {
        $tree = array();
        foreach ($children as $child) {
            if (isset($parents[$child['id']])) {
                $child['children'] =
                    $this->createBranch($parents, $parents[$child['id']]);
            }
            $tree[] = $child;
        } 
        return $tree;
    }

    /**
     * Finds a given taxon id in an array structured as a tree
     */
    private function findTaxonInTree($taxon, $tree)
    {
        if ($this->branch) {
            return;
        }

        foreach ($tree as $branch) {
            if ($branch['id'] == $taxon) {
                $this->branch = $branch;
                break;
            }

            if (array_key_exists('children', $branch)){
                $this->findTaxonInTree($taxon, $branch['children']);
            }

        }
    }

    /**
     * returns an array containing a list of all taxon ids in the given branch
     */
    private function extractTaxonIdsFromBranch($taxonIds, $branch)
    {
        $taxonIds[] = $branch['id'];

        if (array_key_exists('children', $branch)) {
            foreach ($branch['children'] as $child) {
                $taxonIds = $this->extractTaxonIdsFromBranch($taxonIds, $child);
            }
        }

        return $taxonIds;
    }

    /**
     * Executes a search for all entries and returns their IDs
     */
    private function searchAllEntries($sc)
    {
        // now we can retrieve all entries that match (AND / OR operator) or don't match (NOT operator) at least one id in the list
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select('e.id')
            ->from('AppBundle:Entry', 'e')
            ->where('e.status = :status')
            ->orWhere('e.status = :statusAcceptedValidator')
            ->orWhere('e.status = :statusRefusedValidator')
            ->setParameter('status', EntryStatus::ACCEPTED_CURATOR)
            ->setParameter('statusAcceptedValidator', EntryStatus::ACCEPTED_VALIDATOR)
            ->setParameter('statusRefusedValidator', EntryStatus::REFUSED_VALIDATOR);

        if($sc->isGranted('ROLE_CURATOR')) {
          $qb
            ->orWhere('e.status = :statusImported')
            ->orWhere('e.status = :statusTemporary')
            ->setParameter('statusImported', EntryStatus::IMPORTED)
            ->setParameter('statusTemporary', EntryStatus::TEMPORARY);

        };

        return $qb->getQuery()->getResult();
    }


    /**
     * Adds a join to mutation table if it isn't already in the querybuilder
     */
    private function addMutationJoin($qb, $joinAlias = 'm', $rootAlias = 'e')
    {
      $isJoined = $this->mutationJoinExists($qb, $rootAlias);

      // add the join if it isn't present
      if (!$isJoined) {
        $qb->innerJoin('AppBundle:Mutation', $joinAlias, 'WITH', $joinAlias.'.entry = '.$rootAlias);
      }

      return $qb;
    }

    /**
     * Checks if a mutation join is already present in the querybuilder
     */
    private function mutationJoinExists($qb, $rootAlias)
    {
      $mutationTable = 'AppBundle:Mutation';
      $dqlParts = $qb->getDqlParts();

      // check if there are joins
      if (!array_key_exists('join', $dqlParts) || !is_array($dqlParts['join'])) {
        return false;
      }

      // check if the mutation join exists
      $foundMutationJoin = false;
      if (array_key_exists($rootAlias, $dqlParts['join'])) {
        foreach ($dqlParts['join'][$rootAlias] as $join) {
          if ($join->getJoin() == $mutationTable) {
            $foundMutationJoin = true;
            break;
          }
        }
      }

      return $foundMutationJoin;
    }

}
