<?php

/*

 Copyright 2019 CNRS.

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License,
 or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/


namespace AppBundle\Repository;

use Doctrine\ORM\EntityRepository;
use AppBundle\Entity\EntryStatus;
use AppBundle\Repository\EntryRepository;

/**
 * MutationRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class MutationRepository extends EntityRepository
{
	public function validatorsByEntries() {
      $em = $this->getEntityManager();
      $temp = new \DateTime();
      $interval = new \DateInterval('P1M');//1 month
      $last = $temp->sub($interval);
      $sql = $em->createQuery("SELECT m FROM AppBundle:Mutation m INNER JOIN AppBundle:Entry e WHEN m.entry = e WHERE (e.tempDateValidation IS NOT NULL AND e.dateEmail < :last AND e.dateEmail IS NOT NULL) OR (e.tempDateValidation IS NOT NULL AND e.dateEmail IS NULL) GROUP BY e.id")->setParameter('last', $last)->getResult();
      return $sql;
    }

    public function listValidatorEntries($validator)
    {   
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('m.id as mid, e.id, e.gepheId, e.geneGephebase')
            ->from('AppBundle:Mutation', 'm')
            ->innerJoin('AppBundle:Entry','e','WITH','m.entry = e')
            ->innerJoin('AppBundle:EntryStatus', 'es', 'WITH', 'e.status = es')
            ->innerJoin('AppBundle:User', 'u', 'WITH', 'm.validator = u')
            ->where('u.id = :validator')
            ->andWhere('es.id = :validate')
            ->groupBy('e.id')
            ->setParameters(array(':validator'=> $validator->getId(), ':validate' => EntryStatus::ACCEPTED_CURATOR));

        $query = $qb->getQuery();

        try 
        {
            $mutations = $query->getResult();

            // we need to fetch traits and taxon B as well
            $traits = $this->getEntityManager()->getRepository('AppBundle:Entry')->findAllTraits();
            $taxonBs = $this->getEntityManager()->getRepository('AppBundle:Entry')->findAllTaxons('B');

            foreach ($mutations as $key => $mutation) {
                // add traits to array
                $this->getEntityManager()->getRepository('AppBundle:Entry')->addCollectionItemToEntryArray('traits', $traits, $mutation, $key, $mutations);
                // add taxon B to array
                $this->getEntityManager()->getRepository('AppBundle:Entry')->addCollectionItemToEntryArray('taxonB', $taxonBs, $mutation, $key, $mutations);
            }

            return $mutations;
           
        } 
        catch (\Doctrine\ORM\NoResultException $e) 
        {
            return null;
        }
    }

    /**
     * Retrieve data for a table export based on list of mutation ids.
     * If the group genes or group haplotypes option are selected, we will also group the related data
     */
    public function tableExportByMutationId($mutationGroups)
    {
        $uniqueMutationGroups = array();
        foreach ($mutationGroups as $key => $mutationGroup) {
            $uniqueMutationGroups[$key] = array_unique($mutationGroup);
        }

        // array that will store a list of all distinct ids
        $mutationIds = array();
        foreach ($uniqueMutationGroups as $key => $group) {
            foreach ($group as $id) {
                $mutationIds[] = $id;
            }
        }

        $em = $this->getEntityManager();

        $entries = $em->createQuery('SELECT e.id AS id,
            m.id as mutationId,
            e.gepheId AS gepheId,
            e.geneGephebase,
            g.id AS geneId,
            g.name AS geneName,
            g.uniProtKbId,
            e.genbankId,
            e.ancestralState,
            e.taxonomicStatus,
            e.comments,
            g.organism,
            g.string AS string,
            g.sequenceSimilarities AS similarities,
            u.username
            FROM AppBundle:Entry e 
            LEFT JOIN AppBundle:Gene g WITH e.gene = g.id
            LEFT JOIN AppBundle:User u WITH e.mainCurator = u.id
            INNER JOIN AppBundle:Mutation m WITH m.entry = e
            WHERE m.id IN ('.implode(',', array_map('intval',$mutationIds)).') GROUP BY m.id ORDER BY e.id ASC'
        )->getResult();

        $entryRepository = $this->getEntityManager()->getRepository('AppBundle:Entry');
       
        $complexTraits = $entryRepository->findAllComplexTraits();
        $complexTaxonAs = $entryRepository->findAllComplexTaxons('A');
        $complexTaxonBs = $entryRepository->findAllComplexTaxons('B');
        $goMoleculars = $entryRepository->findAllGo('goMolecular');
        $goBiologicals = $entryRepository->findAllGo('goBiological');
        $goCellulars = $entryRepository->findAllGo('goCellular');
        $geneSynonyms = $entryRepository->findAllSynonyms();
        $mutations = $entryRepository->findAllMutations();
        $feedbacks = $entryRepository->findAllFeedbacks();

        foreach ($entries as $key => &$entry) {
            // add traits to array
            $entryRepository->addCollectionItemToEntryArray('complexTraits', $complexTraits, $entry, $key, $entries);
            // add complex taxon As to array
            $entryRepository->addCollectionItemToEntryArray('complexTaxonAs', $complexTaxonAs, $entry, $key, $entries);
            // add complex taxon Bs to array
            $entryRepository->addCollectionItemToEntryArray('complexTaxonBs', $complexTaxonBs, $entry, $key, $entries);
            // add feedbacks to array
            $entryRepository->addCollectionItemToEntryArray('feedbacks', $feedbacks, $entry, $key, $entries);
            // add go Moleculars to array
            $entryRepository->addCollectionItemToEntryArray('goMoleculars', $goMoleculars, $entry, $key, $entries, 'geneId');
            // add go Biological to array
            $entryRepository->addCollectionItemToEntryArray('goBiologicals', $goBiologicals, $entry, $key, $entries, 'geneId');
            // add go Cellular to array
            $entryRepository->addCollectionItemToEntryArray('goCellulars', $goCellulars, $entry, $key, $entries, 'geneId');
            // add gene synonyms to array
            $entryRepository->addCollectionItemToEntryArray('geneSynonyms', $geneSynonyms, $entry, $key, $entries, 'geneId');

            $mutationId = $entry['mutationId'];
            $entryId = $entry['id'];

            if (!array_key_exists($entryId, $mutations)) {
                continue;
            }

            foreach ($mutations[$entryId] as $mutation) {
                if ($mutation['mutationId'] == $mutationId) {

                    $entry['mutations'] = $mutation;
                    break;
                }
            }
        }

        $groupedEntries = $this->groupMutationData($entries, $uniqueMutationGroups);

        return $groupedEntries;
    }

    /**
     * Groups mutation data according to the mutation groups passed in parameter.
     */
    private function groupMutationData($entries, $mutationGroups)
    {
        // add the mutation id as the index of the array of mutations
        $mutations = array();
        foreach ($entries as $entry) {
            $mutations[$entry['mutationId']] = $entry;
        }

        $groupedMutations = array();
        foreach ($mutationGroups as $key => $group) {
            foreach ($group as $mutationId) {

                // check that the mutation data has been loaded from the database
                if (!array_key_exists($mutationId, $mutations)) {
                    continue;
                }

                // if the key doesn't exist, this is the first mutation of the group, and we add all the data
                if (!array_key_exists($key, $groupedMutations)) {
                    $groupedMutations[$key] = $mutations[$mutationId];
                    // reset the mutation index, it will be replaced by an array of mutations
                    $groupedMutations[$key]['mutations'] = array();
                }

                $groupedMutations[$key]['mutations'][] = $mutations[$mutationId]['mutations'];
            }
        }

        return $groupedMutations;
    }
}
